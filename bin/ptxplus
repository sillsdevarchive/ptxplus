#!/usr/bin/python
# -*- coding: utf-8 -*-
# version: 20080423
# By Dennis Drescher (dennis_drescher at sil.org)

# This script has been tested on Python 2.5.1 (Ubuntu)
# it may not work right with earlier versions.

#############################################################
################ Description/Documentation ##################
#############################################################

# One script to rule them all. This is the mother script of
# the whole system. This script will drive all processes and
# keep track of what happens in the project log in each
# respective project.

# History:
# 20080613 - djd - Initial draft
# 20081023 - djd - Refactor .project.conf structure changes
# 20081028 - djd - Removed system logging. Only using
#        process logging now.


#############################################################
######################### Load Modules ######################
#############################################################
# Firstly, import all the standard Python modules we need for
# this process

import sys, os, codecs, shutil

basePath = os.environ.get('PTXPLUS_BASE')
if not basePath :
	basePath = "/usr/share/xetex-ptxplus"
	os.environ['PTXPLUS_BASE'] = basePath

#sys.path.append(basePath + '/bin/python')
#sys.path.append(basePath + '/bin/python/lib_system')
#sys.path.append(basePath + '/bin/python/lib_scripture')
sys.path.insert(0, basePath + '/bin/python')
sys.path.insert(0, basePath + '/bin/python/lib_system')
sys.path.insert(0, basePath + '/bin/python/lib_scripture')

# Import supporting local classes
#from lib_system.tools import *
from tools import *
from log_manager import *
from error_manager import *

# Instantiate classes
tools            = Tools()
error_manager        = ErrorManager()
log_manager        = LogManager()

# We want to see one valid arguments given. However, that
# may not happen so this script is all about testing the
# arguments given and getting things directed to the right
# place.

command = ""
bkid = ""

# There should always be at least one arg, look for a second
if len(sys.argv) >= 2 :

	# The second argv is normally the file name or book ID
	componentScripture = tools.getSettingsObject()['System']['Binding']['MATTER_OT']
	componentScripture = componentScripture + tools.getSettingsObject()['System']['Binding']['MATTER_NT']
	componentScripture = componentScripture.split()
	# This part only works if we are processing Scripture components (books with IDs)
	if len(componentScripture) > 0 :
		for book in componentScripture :
			# We will lc that for consistency
			if sys.argv[1].lower() == book.lower() :
				bkid = sys.argv[1].lower()

	# If we found an argv with an lc bkid then that becomes the command
	if bkid != "" :
		command = bkid
	# Otherwise we'll just read it in raw
	else :
		command = sys.argv[1]

# Other wise we'll just start up the manager
else :
	tools.userMessage("Welcome to XeTeX-ptxplus!")
	command = "manage"


#############################################################
################# Define Script functions ###################
#############################################################


def setupNewProject () :
	'''Looks like we need to setup a new project. A new project will be
		setup in the CWD. If that isn't right, oh well, the user should
		pay more attention. :-)'''

# It would be good to get some input from the user on this.
# However, the way the project manager works, the following
# is not that useful so it is commented for now.
	# Look for a .project.conf file in the cwd. If there is none, ask
	# if we need to create a new project.
#    if tools.isProjectFolder() == False :
#        newProjectpath = os.path.abspath(sys.argv[2])
#        if tools.userConfirm("Would you like to start a new project. Create a new project here? " + newProjectpath) != True :
#            return
#        else :
#            # Send out the make new project command
#            mod = __import__('make_new_project')
#            mod.doIt(newProjectpath)

	# Send out the make new project command
	mod = __import__('make_new_project')
	mod.doIt(sys.argv[2])


def restoreFromBackup () :
	'''Restore a project from the last back up.'''

	# Check to see if the backup file exists
	if tools.isBackedUp() == True :
		mod = __import__("restore_project")
		mod.doIt()
	else :
		tools.userMessage("ERROR: This project could not be restored from backup. No backup file found or project does not exist.")


def importProject () :
	'''Import a new project from the archive area.'''

	# This should just go to where the archives are kept and bring back a list for
	# the user to choose from. For now we'll just use a path and file name so we
	# can point to anything.
	if len(sys.argv) < 3 :
		archiveFile = tools.userInput('REQUEST: Please enter the path and filename of the archive file to import: ')
	else :
		archiveFile = sys.argv[2]

	mod = __import__("import_project")
	mod.doIt(archiveFile)


def archiveProject () :
	'''Do an archive of any project. If a file name argument is passed we know
		the ptxplus-manager is initiating the call. If no file name is sent
		then it is a blind call from the ptxplus program and will use default
		settings to produce an archive file in the Archive folder.'''

	if len(sys.argv) < 3 :
		fileName = tools.getProjectID()
	else :
		fileName = sys.argv[2]

	mod = __import__("archive_project")
	mod.doIt(fileName)


def backupProject () :
	'''Do a simple backup of the current project.'''

	mod = __import__("backup_project")
	tools.userMessage("INFO: Backing up project, please wait...")
	mod.doIt()


#############################################################
################# Main Body of the Script ###################
#############################################################

noCommandMsg = "Sorry, no valid command was given. Try again."

if command == "manage" :
	# In this instance we want to just call the GUI manager and release control cleanly
	os.execl(basePath + "/bin/python/ptxplus-manager/ptxplus-manager")

elif command == "help" :
	# We have to help the user get started so this will allow us to call help
	# even if a project is not open.
	os.system('zim ' + basePath + '/resources/Documentation/Help/ Home.txt')

elif command == "about" :
	# Give the user an "about" window even if not in a project.
	os.system('zim ' + basePath + '/resources/Documentation/Help/ About.txt')

elif command == "version" :
	# Give the user the current system version number
	tools.userMessage('INFO: Current version: ' + tools.getSystemVersion())

elif command == "user" :
	# Set the system user name
		tools.userMessage('INFO: ' + tools.getSystemUser())

elif command == "set-user" :
	# Set the system user name
	try :
		if sys.argv[2] :
			tools.setSystemUser(sys.argv[2])
	except :
		tools.userMessage('ERROR: No user name given, try again.')

elif command == "set-source-home" :
	# Set the source home folder
	try :
		tools.setSystemSourceHome(sys.argv[2])

	except :
		tools.userMessage('ERROR: Problem setting source path, please try again.')

elif command == "example" :
	# This is a special instance of the import function to facilitate
	# running the example project for demonstration purposes.

	try :
		if sys.argv[2] :
			if os.path.isdir(sys.argv[2]) == True :
				os.chdir(sys.argv[2])
			else :
				os.mkdir(sys.argv[2])
				os.chdir(sys.argv[2])

	except :
		os.mkdir("ptxplus-example")
		os.chdir("ptxplus-example")


	mod = __import__("import_project")
	# For now, I've hard coded the path to the example file. Shame on me!
	mod.doIt(basePath + '/resources/Documentation/Help/default_example.tar.gz')

else :
	# This will test to see if we are in the project or not
	# To do system commands we need to be one folder above
	# However, if we find we are in a project folder, then
	# we will perform project processes on that specific project
	if tools.inProject() == True :

		# Sort out the commands. These are commands that
		# can be used from inside the project area
		if command == "restore" :
			restoreFromBackup()
		elif command == "backup" :
			backupProject()
		elif command == "archive" :
			archiveProject()
		elif command == "import" or command == "setup" :
			tools.userMessage('ERROR: Sorry, that command cannot be used in this location.')

		else :

			# So, it looks like we are going to do some work on the project so we
			# should do some tests and even automatic repairs and updates.

			# Right off we need to tell the user if the project is locked (only if it is locked)


			# Update the .project.conf file if it needs it
			mod = __import__("update_project_settings")
			mod.doIt()

			# Next look to see if the fonts.conf file needs localizing
			from font_manager import *
			font_manager    = FontManager()
			font_manager.localiseFontsConf()

			# There are a number of processes we may want to run before we want to
			# start the actual process. These are done via the GlobalProcesses listed
			# in the .project.conf file.
			#log_manager.logItSystem("INFO", "Looking for global project processes to run.")

			# Look for all the global processes that need to be run
			taskList = []
			taskList = log_manager._settings['System']['Processes']['globalProcesses']
			# Get rid of the old error log file.
			error_manager.deleteErrorLog()
			for thisTask in taskList :

				# Initialize the log manager to do its thing
				log_manager.initializeLog(thisTask, "NA", "", "", "")

				# For running each process we use one centralized task runner in tools.
				tools.taskRunner(log_manager, thisTask)

				# Close out the process by reporting to the log file
				log_manager.closeOutSessionLog()

			# Anounce any errors we have found
			warn = ""
			if log_manager._warningCount > 0 or log_manager._errorCount > 0 :
				warn = " (Warnings = " + str(log_manager._warningCount) + ")"
				tools.userMessage("ERROR: " + thisTask + " completed with " + str(log_manager._errorCount) + " errors" + warn)

			# At this point we want to check to see if a few certain switches
			# are set to false. If they are, we will run a couple makefile
			# clean up commands before the command that the user is calling
			# for is run. (Right now we are limiting this action to Scripture
			# publications.)
			pubType = tools.getSettingsObject()['Format']['publicationType']
			locked = tools.getSettingsObject()['Project']['SourceText']['LOCKED']
			useIllustrations = tools.getSettingsObject()['Format']['PageLayout']['Switches']['USE_ILLUSTRATIONS']
			useAdjustments = tools.getSettingsObject()['Format']['PageLayout']['Switches']['USE_ADJUSTMENTS']
			if locked == 0 :
				if pubType.lower() == 'scripture' :
					if useIllustrations.lower() == 'false' :
						tools.makefileCommand('picfile-clean-all')
					if useAdjustments.lower() == 'false' :
						tools.makefileCommand('adjfile-clean-all')

			# The project should be ready now
			tools.userMessage("\nINFO: Starting: " +  command)

			# Now send off the command to makefile
			errorCode = tools.makefileCommand(command)
			if errorCode != 0 :
				tools.userMessage("ERROR: Makefile process failed. (Error code: " + str(errorCode) + ")")

			# Report our errors to the terminal
			error_manager.outputProcessErrorReport()

	elif tools.inProject() == False :
		# These are system level commands and have to be used
		# from outside the project area
		if command == "setup" :
			setupNewProject()
		elif command == "import" :
			importProject()
		else :
			tools.userMessage("ERROR: There does not seem to be a valid project in this location and the [" + command + "] command is not recognized in this context.")

	else :
		tools.userMessage('ERROR: ' + noCommandMsg)


# All done
tools.userMessage("\n\t\tThank you, please come again!\n")
